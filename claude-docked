#!/usr/bin/env bash
set -euo pipefail

show_help() {
  cat <<'EOF'
Usage:
  claude-docked [options] [main_dir] [extra_dir ...] [-- <tool args...>]

Description:
  Runs AI coding assistants inside a Docker container.

Options:
  -t, --tool TOOL    AI tool to run: claude (default), codex, gemini, vibe
  -H PORT[:HOSTPORT] Forward host port to container localhost (can be repeated)
  -p HOST:CONTAINER  Publish container port to host (can be repeated)
  -s, --shell        Start a bash shell instead of the AI tool (for debugging)
  -S, --ssh          Enable SSH agent forwarding (for git push)
  -w, --worktree     Auto-include git worktree's main repository (skip prompt)
  -y, --yolo         Skip all permission prompts (tool-specific flag)
  -h, --help         Show this help message

Behavior:
  - If no directories are provided, defaults to the current directory.
  - Directories are mounted at their original host paths for full path parity.
  - Additional directories are automatically added via --add-dir (claude, codex only).
  - Tool configs (~/.claude, ~/.codex, ~/.gemini, ~/.vibe) and Maven cache (~/.m2) are bind-mounted.
  - SSH agent forwarding is disabled by default; use --ssh to enable (for git push).
  - Git worktrees are detected; main repository is included for full git access.

Examples:
  claude-docked                      # Run claude in current directory
  claude-docked -t codex .           # Run codex instead
  claude-docked -t gemini .          # Run gemini instead
  claude-docked -t vibe .            # Run vibe instead
  claude-docked . ../other/project   # Mount extra directories
  claude-docked . -- --model sonnet  # Pass args to tool
  claude-docked -y -t codex .        # Codex with --yolo
  claude-docked -S .                 # Enable SSH agent (for git push)
  claude-docked -s                   # Debug shell in current directory
  claude-docked -p 8080:8080 .       # Expose port 8080
  claude-docked -H 3845 .            # Forward host:3845 to container localhost:3845

Build the image:
  docker build -t claude-contained .
EOF
}

if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  show_help
  exit 0
fi

# Parse flags (can appear in any order)
shell_mode=0
ssh_mode=0
worktree_mode=0
yolo_mode=0
tool="claude"
port_maps=()
host_forwards=()
while [[ "${1:-}" == -* ]]; do
  case "${1:-}" in
    -s|--shell)
      shell_mode=1
      shift
      ;;
    -S|--ssh)
      ssh_mode=1
      shift
      ;;
    -w|--worktree)
      worktree_mode=1
      shift
      ;;
    -y|--yolo)
      yolo_mode=1
      shift
      ;;
    -t|--tool)
      shift
      tool="$1"
      shift
      ;;
    -p)
      shift
      port_maps+=("$1")
      shift
      ;;
    -H)
      shift
      host_forwards+=("$1")
      shift
      ;;
    *)
      break
      ;;
  esac
done

# Ensure Docker is running
if ! docker info &>/dev/null; then
  read -p "Docker is not running. Start Docker Desktop? [Y/n] " answer
  case "${answer:-Y}" in
    [Yy]* )
      open -a Docker
      echo "Waiting for Docker to start..."
      while ! docker info &>/dev/null; do sleep 1; done
      ;;
    * ) echo "Aborted."; exit 1 ;;
  esac
fi

if [[ $# -eq 0 ]]; then
  set -- "."
fi

# Split directories (before --) vs tool args (after --)
paths=()
tool_args=()
seen_sep=0
for a in "$@"; do
  if [[ "$a" == "--" ]]; then
    seen_sep=1
    continue
  fi
  if [[ $seen_sep -eq 0 ]]; then
    paths+=("$a")
  else
    tool_args+=("$a")
  fi
done

# If user did: claude-docked -- <claude args...>
if [[ ${#paths[@]} -eq 0 ]]; then
  paths+=(".")
fi

resolve_path() {
  if command -v python3 &>/dev/null; then
    python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$1"
  elif command -v realpath &>/dev/null; then
    realpath "$1"
  elif command -v readlink &>/dev/null && readlink -f / &>/dev/null; then
    readlink -f "$1"
  else
    # Fallback: works for directories
    (cd "$1" 2>/dev/null && pwd) || echo "$1"
  fi
}

# Detect if directory is a git worktree and return main repo path
# Returns empty string if not a worktree
get_worktree_main_repo() {
  local dir="$1"
  local git_file="${dir}/.git"

  # Check if .git is a file (worktree) not a directory (regular repo)
  if [[ -f "$git_file" ]]; then
    # Use git to find the main repository's .git directory
    local common_dir
    common_dir="$(cd "$dir" && git rev-parse --git-common-dir 2>/dev/null)" || return

    # Get the main repo root (parent of .git)
    if [[ -n "$common_dir" && "$common_dir" != ".git" ]]; then
      dirname "$(resolve_path "$common_dir")"
    fi
  fi
}

main_host="$(resolve_path "${paths[0]}")"

# Check if main directory is a git worktree
worktree_main_repo=""
worktree_main_repo="$(get_worktree_main_repo "$main_host")" || true

if [[ -n "$worktree_main_repo" ]]; then
  if [[ $worktree_mode -eq 1 ]]; then
    # Auto-include mode: just inform the user
    echo "Worktree detected: also including main repository ${worktree_main_repo}"
  else
    # Prompt mode: ask the user
    echo "Working directory is a git worktree linked to: ${worktree_main_repo}"
    read -p "Include main repository for full git access? [Y/n] " answer
    case "${answer:-Y}" in
      [Yy]* ) : ;;  # Continue, will be included
      * ) worktree_main_repo="" ;;  # Don't include
    esac
  fi
fi

# Capture host HOME for path parity
HOST_HOME="$HOME"
HOST_CLAUDE_DIR="${HOST_HOME}/.claude"
HOST_CODEX_DIR="${HOST_HOME}/.codex"
HOST_GEMINI_DIR="${HOST_HOME}/.gemini"
HOST_VIBE_DIR="${HOST_HOME}/.vibe"
HOST_M2_DIR="${HOST_HOME}/.m2"
HOST_GITCONFIG="${HOST_HOME}/.gitconfig"

# Ensure persistent directories exist on host
mkdir -p "${HOST_CLAUDE_DIR}" "${HOST_CODEX_DIR}" "${HOST_GEMINI_DIR}" "${HOST_VIBE_DIR}" "${HOST_M2_DIR}"

# Build container args
CLAUDE_MEMORY="${CLAUDE_MEMORY:-8g}"
container_argv=(
  docker run --rm -it
  --memory "${CLAUDE_MEMORY}"
  --name "claude-docked-$$"
  -e "HOST_HOME=${HOST_HOME}"
  -e "HOST_UID=$(id -u)"
  -e "HOST_GID=$(id -g)"
  -w "${main_host}"
  --mount "type=bind,src=${HOST_CLAUDE_DIR},dst=${HOST_HOME}/.claude"
  --mount "type=bind,src=${HOST_CODEX_DIR},dst=${HOST_HOME}/.codex"
  --mount "type=bind,src=${HOST_GEMINI_DIR},dst=${HOST_HOME}/.gemini"
  --mount "type=bind,src=${HOST_VIBE_DIR},dst=${HOST_HOME}/.vibe"
  --mount "type=bind,src=${HOST_M2_DIR},dst=${HOST_HOME}/.m2"
  --mount "type=bind,src=${main_host},dst=${main_host}"
)

# Mount worktree's main repository if needed
if [[ -n "$worktree_main_repo" ]]; then
  container_argv+=( --mount "type=bind,src=${worktree_main_repo},dst=${worktree_main_repo}" )
fi

# Add port mappings
for pm in "${port_maps[@]+"${port_maps[@]}"}"; do
  container_argv+=( -p "$pm" )
done

# Add host port forwards (container localhost â†’ host)
if [[ ${#host_forwards[@]} -gt 0 ]]; then
  IFS=','; forwards_str="${host_forwards[*]}"; unset IFS
  container_argv+=( -e "HOST_FORWARD_PORTS=${forwards_str}" )
fi

# SSH agent forwarding (opt-in for security)
if [[ $ssh_mode -eq 1 ]]; then
  # macOS Docker Desktop: use the special bridged socket
  # Linux: mount the actual socket
  if [[ "$(uname)" == "Darwin" ]]; then
    container_argv+=(
      --mount "type=bind,src=/run/host-services/ssh-auth.sock,dst=/ssh-agent"
      -e "SSH_AUTH_SOCK=/ssh-agent"
    )
  elif [[ -n "${SSH_AUTH_SOCK:-}" ]]; then
    container_argv+=(
      -v "${SSH_AUTH_SOCK}:/ssh-agent"
      -e "SSH_AUTH_SOCK=/ssh-agent"
    )
  fi
fi

# On Linux, add host.docker.internal mapping (macOS/Windows have it built-in)
if [[ "$(uname)" == "Linux" ]]; then
  container_argv+=( --add-host "host.docker.internal:host-gateway" )
fi

# Share ~/.claude.json via symlink to shared directory (can't bind-mount individual files)
# See: https://github.com/apple/containerization/issues/79
# Canonical location is ~/.claude-contained/.claude.json; ~/.claude.json is a symlink to it.
# All containers access the same file via virtiofs, so Claude Code's own locking works.
HOST_CLAUDE_CONTAINED="${HOST_HOME}/.claude-contained"
HOST_CLAUDE_JSON="${HOST_HOME}/.claude.json"
SHARED_CLAUDE_JSON="${HOST_CLAUDE_CONTAINED}/.claude.json"
mkdir -p "${HOST_CLAUDE_CONTAINED}"

# Git config (for commit identity)
# Copy to shared directory for consistency with claude-contained (entrypoint copies to ~/.gitconfig)
if [[ -f "${HOST_GITCONFIG}" ]]; then
  cp "${HOST_GITCONFIG}" "${HOST_CLAUDE_CONTAINED}/.gitconfig"
fi

# Migrate/repair: ensure ~/.claude.json is symlink to shared location
if [[ -f "$HOST_CLAUDE_JSON" && ! -L "$HOST_CLAUDE_JSON" ]]; then
  # Host file is regular file (not symlink) - migrate it to shared location
  # This handles: first run, or host Claude Code replaced symlink via atomic write
  mv "$HOST_CLAUDE_JSON" "$SHARED_CLAUDE_JSON"
  ln -s "$SHARED_CLAUDE_JSON" "$HOST_CLAUDE_JSON"
elif [[ -L "$HOST_CLAUDE_JSON" && ! -e "$SHARED_CLAUDE_JSON" ]]; then
  # Symlink exists but target doesn't - broken symlink, remove it
  rm "$HOST_CLAUDE_JSON"
fi

# Ensure symlink exists (if shared file exists but no symlink yet)
if [[ ! -e "$HOST_CLAUDE_JSON" && -f "$SHARED_CLAUDE_JSON" ]]; then
  ln -s "$SHARED_CLAUDE_JSON" "$HOST_CLAUDE_JSON"
fi

# Mount the shared directory for bidirectional ~/.claude.json access
container_argv+=( --mount "type=bind,src=${HOST_CLAUDE_CONTAINED},dst=${HOST_CLAUDE_CONTAINED}" )

# Build tool-specific command
case "$tool" in
  claude)
    tool_argv=(claude)
    [[ $yolo_mode -eq 1 ]] && tool_argv+=(--dangerously-skip-permissions)
    ;;
  codex)
    tool_argv=(codex)
    [[ $yolo_mode -eq 1 ]] && tool_argv+=(--yolo)
    ;;
  gemini)
    tool_argv=(gemini)
    [[ $yolo_mode -eq 1 ]] && tool_argv+=(--yolo)
    ;;
  vibe)
    tool_argv=(vibe)
    [[ $yolo_mode -eq 1 ]] && tool_argv+=(--auto-approve)
    ;;
  *)
    echo "Unknown tool: $tool" >&2
    echo "Supported tools: claude, codex, gemini, vibe" >&2
    exit 1
    ;;
esac

# Additional mounts at original host paths
for p in "${paths[@]:1}"; do
  hp="$(resolve_path "$p")"
  container_argv+=( --mount "type=bind,src=${hp},dst=${hp}" )
  # Only claude and codex support --add-dir
  [[ "$tool" == "claude" || "$tool" == "codex" ]] && tool_argv+=( --add-dir "${hp}" )
done

# Add worktree main repo to agent's folders
if [[ -n "$worktree_main_repo" ]]; then
  [[ "$tool" == "claude" || "$tool" == "codex" ]] && tool_argv+=( --add-dir "${worktree_main_repo}" )
fi

# Append user's tool args
if [[ ${#tool_args[@]} -gt 0 ]]; then
  tool_argv+=( "${tool_args[@]}" )
fi

# Run container
if [[ $shell_mode -eq 1 ]]; then
  exec "${container_argv[@]}" claude-contained:latest bash
else
  exec "${container_argv[@]}" claude-contained:latest "${tool_argv[@]}"
fi
