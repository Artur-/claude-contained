#!/usr/bin/env bash
set -euo pipefail

show_help() {
  cat <<'EOF'
Usage:
  claude-contained [options] [main_dir] [extra_dir ...] [-- <tool args...>]

Description:
  Runs AI coding assistants inside an Apple Containers sandbox.

Options:
  -t, --tool TOOL    AI tool to run: claude (default), codex, gemini, vibe
  -H PORT[:HOSTPORT] Forward host port to container localhost (can be repeated)
  -p HOST:CONTAINER  Publish container port to host (can be repeated)
  -s, --shell        Start a bash shell instead of the AI tool (for debugging)
  -y, --yolo         Skip all permission prompts (tool-specific flag)
  -h, --help         Show this help message

Behavior:
  - If no directories are provided, defaults to the current directory.
  - Directories are mounted at their original host paths for full path parity.
  - Additional directories are automatically added via --add-dir (claude, codex only).
  - Tool configs (~/.claude, ~/.codex, ~/.gemini, ~/.vibe) and Maven cache (~/.m2) are bind-mounted.
  - SSH agent is forwarded (--ssh).

Examples:
  claude-contained                     # Run claude in current directory
  claude-contained -t codex .          # Run codex instead
  claude-contained -t gemini .         # Run gemini instead
  claude-contained -t vibe .           # Run vibe instead
  claude-contained . ../other/project  # Mount extra directories
  claude-contained . -- --model sonnet # Pass args to tool
  claude-contained -y -t codex .       # Codex with --yolo
  claude-contained -s                  # Debug shell in current directory
  claude-contained -p 8080:8080 .      # Expose port 8080
  claude-contained -H 3845 .           # Forward host:3845 to container localhost:3845
EOF
}

if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  show_help
  exit 0
fi

# Parse flags (can appear in any order)
shell_mode=0
yolo_mode=0
tool="claude"
port_maps=()
host_forwards=()
while [[ "${1:-}" == -* ]]; do
  case "${1:-}" in
    -s|--shell)
      shell_mode=1
      shift
      ;;
    -y|--yolo)
      yolo_mode=1
      shift
      ;;
    -t|--tool)
      shift
      tool="$1"
      shift
      ;;
    -p)
      shift
      port_maps+=("$1")
      shift
      ;;
    -H)
      shift
      host_forwards+=("$1")
      shift
      ;;
    *)
      break
      ;;
  esac
done

# Ensure container system is running
if ! container system status &>/dev/null; then
  echo "Starting container system..."
  container system start
fi

if [[ $# -eq 0 ]]; then
  set -- "."
fi

# Split directories (before --) vs tool args (after --)
paths=()
tool_args=()
seen_sep=0
for a in "$@"; do
  if [[ "$a" == "--" ]]; then
    seen_sep=1
    continue
  fi
  if [[ $seen_sep -eq 0 ]]; then
    paths+=("$a")
  else
    tool_args+=("$a")
  fi
done

# If user did: claude-contained -- <claude args...>
if [[ ${#paths[@]} -eq 0 ]]; then
  paths+=(".")
fi

resolve_path() {
  if command -v python3 &>/dev/null; then
    python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$1"
  elif command -v realpath &>/dev/null; then
    realpath "$1"
  elif command -v readlink &>/dev/null && readlink -f / &>/dev/null; then
    readlink -f "$1"
  else
    # Fallback: works for directories
    (cd "$1" 2>/dev/null && pwd) || echo "$1"
  fi
}

main_host="$(resolve_path "${paths[0]}")"

# Capture host HOME for path parity
HOST_HOME="$HOME"
HOST_CLAUDE_DIR="${HOST_HOME}/.claude"
HOST_CODEX_DIR="${HOST_HOME}/.codex"
HOST_GEMINI_DIR="${HOST_HOME}/.gemini"
HOST_VIBE_DIR="${HOST_HOME}/.vibe"
HOST_M2_DIR="${HOST_HOME}/.m2"

# Ensure persistent directories exist on host
mkdir -p "${HOST_CLAUDE_DIR}" "${HOST_CODEX_DIR}" "${HOST_GEMINI_DIR}" "${HOST_VIBE_DIR}" "${HOST_M2_DIR}"

# Capture Git config for container (if set)
GIT_USER_NAME="$(git config user.name 2>/dev/null || true)"
GIT_USER_EMAIL="$(git config user.email 2>/dev/null || true)"

# Build container args
CLAUDE_MEMORY="${CLAUDE_MEMORY:-8g}"
container_argv=(
  container run --rm -it
  --memory "${CLAUDE_MEMORY}"
  --name "claude-contained-$$"
  --ssh
  -e "HOST_HOME=${HOST_HOME}"
  -e "HOST_UID=$(id -u)"
  -e "HOST_GID=$(id -g)"
  -w "${main_host}"
)

# Add Git config environment variables if set
if [[ -n "$GIT_USER_NAME" ]]; then
  container_argv+=(
    -e "GIT_AUTHOR_NAME=${GIT_USER_NAME}"
    -e "GIT_COMMITTER_NAME=${GIT_USER_NAME}"
  )
fi
if [[ -n "$GIT_USER_EMAIL" ]]; then
  container_argv+=(
    -e "GIT_AUTHOR_EMAIL=${GIT_USER_EMAIL}"
    -e "GIT_COMMITTER_EMAIL=${GIT_USER_EMAIL}"
  )
fi

# Add mounts
container_argv+=(
  --mount "type=bind,src=${HOST_CLAUDE_DIR},dst=${HOST_HOME}/.claude"
  --mount "type=bind,src=${HOST_CODEX_DIR},dst=${HOST_HOME}/.codex"
  --mount "type=bind,src=${HOST_GEMINI_DIR},dst=${HOST_HOME}/.gemini"
  --mount "type=bind,src=${HOST_VIBE_DIR},dst=${HOST_HOME}/.vibe"
  --mount "type=bind,src=${HOST_M2_DIR},dst=${HOST_HOME}/.m2"
  --mount "type=bind,src=${main_host},dst=${main_host}"
)

# Add port mappings
for pm in "${port_maps[@]+"${port_maps[@]}"}"; do
  container_argv+=( -p "$pm" )
done

# Add host port forwards (container localhost â†’ host)
if [[ ${#host_forwards[@]} -gt 0 ]]; then
  IFS=','; forwards_str="${host_forwards[*]}"; unset IFS
  container_argv+=( -e "HOST_FORWARD_PORTS=${forwards_str}" )
fi

# Share ~/.claude.json via symlink to shared directory (can't bind-mount individual files)
# See: https://github.com/apple/containerization/issues/79
# Canonical location is ~/.claude-contained/.claude.json; ~/.claude.json is a symlink to it.
# All containers access the same file via virtiofs, so Claude Code's own locking works.
HOST_CLAUDE_CONTAINED="${HOST_HOME}/.claude-contained"
HOST_CLAUDE_JSON="${HOST_HOME}/.claude.json"
SHARED_CLAUDE_JSON="${HOST_CLAUDE_CONTAINED}/.claude.json"
mkdir -p "${HOST_CLAUDE_CONTAINED}"

# Migrate/repair: ensure ~/.claude.json is symlink to shared location
if [[ -f "$HOST_CLAUDE_JSON" && ! -L "$HOST_CLAUDE_JSON" ]]; then
  # Host file is regular file (not symlink) - migrate it to shared location
  # This handles: first run, or host Claude Code replaced symlink via atomic write
  mv "$HOST_CLAUDE_JSON" "$SHARED_CLAUDE_JSON"
  ln -s "$SHARED_CLAUDE_JSON" "$HOST_CLAUDE_JSON"
elif [[ -L "$HOST_CLAUDE_JSON" && ! -e "$SHARED_CLAUDE_JSON" ]]; then
  # Symlink exists but target doesn't - broken symlink, remove it
  rm "$HOST_CLAUDE_JSON"
fi

# Ensure symlink exists (if shared file exists but no symlink yet)
if [[ ! -e "$HOST_CLAUDE_JSON" && -f "$SHARED_CLAUDE_JSON" ]]; then
  ln -s "$SHARED_CLAUDE_JSON" "$HOST_CLAUDE_JSON"
fi

# Mount the shared directory for bidirectional ~/.claude.json access
container_argv+=( --mount "type=bind,src=${HOST_CLAUDE_CONTAINED},dst=${HOST_CLAUDE_CONTAINED}" )

# Build tool-specific command
case "$tool" in
  claude)
    tool_argv=(claude)
    [[ $yolo_mode -eq 1 ]] && tool_argv+=(--dangerously-skip-permissions)
    ;;
  codex)
    tool_argv=(codex)
    [[ $yolo_mode -eq 1 ]] && tool_argv+=(--yolo)
    ;;
  gemini)
    tool_argv=(gemini)
    [[ $yolo_mode -eq 1 ]] && tool_argv+=(--yolo)
    ;;
  vibe)
    tool_argv=(vibe)
    [[ $yolo_mode -eq 1 ]] && tool_argv+=(--auto-approve)
    ;;
  *)
    echo "Unknown tool: $tool" >&2
    echo "Supported tools: claude, codex, gemini, vibe" >&2
    exit 1
    ;;
esac

# Additional mounts at original host paths
for p in "${paths[@]:1}"; do
  hp="$(resolve_path "$p")"
  container_argv+=( --mount "type=bind,src=${hp},dst=${hp}" )
  # Only claude and codex support --add-dir
  [[ "$tool" == "claude" || "$tool" == "codex" ]] && tool_argv+=( --add-dir "${hp}" )
done

# Append user's tool args
if [[ ${#tool_args[@]} -gt 0 ]]; then
  tool_argv+=( "${tool_args[@]}" )
fi

# Run container
if [[ $shell_mode -eq 1 ]]; then
  exec "${container_argv[@]}" claude-contained:latest bash
else
  exec "${container_argv[@]}" claude-contained:latest "${tool_argv[@]}"
fi
