#!/usr/bin/env bash
set -euo pipefail

show_help() {
  cat <<'EOF'
Usage:
  claude-contained [options] [main_dir] [extra_dir ...] [-- <claude args...>]

Description:
  Runs Claude Code inside an Apple Containers sandbox.

Options:
  -s, --shell    Start a bash shell instead of Claude Code (for debugging)
  -h, --help     Show this help message

Behavior:
  - If no directories are provided, defaults to the current directory.
  - Directories are mounted at their original host paths for full path parity.
  - Additional directories are automatically added to Claude using --add-dir.
  - Claude state (~/.claude) is bind-mounted from the host for persistence.
  - SSH agent is forwarded (--ssh).

Examples:
  claude-contained
  claude-contained .
  claude-contained . ../other/project ../shared/lib
  claude-contained . ../other/project -- --model sonnet --verbose
  claude-contained -- --help
  claude-contained -s                  # Debug shell in current directory
  claude-contained -s ./my-project     # Debug shell with specific directory
EOF
}

if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  show_help
  exit 0
fi

shell_mode=0
if [[ "${1:-}" == "-s" || "${1:-}" == "--shell" ]]; then
  shell_mode=1
  shift
fi

if [[ $# -eq 0 ]]; then
  set -- "."
fi

# Split directories (before --) vs Claude args (after --)
paths=()
claude_args=()
seen_sep=0
for a in "$@"; do
  if [[ "$a" == "--" ]]; then
    seen_sep=1
    continue
  fi
  if [[ $seen_sep -eq 0 ]]; then
    paths+=("$a")
  else
    claude_args+=("$a")
  fi
done

# If user did: claude-contained -- <claude args...>
if [[ ${#paths[@]} -eq 0 ]]; then
  paths+=(".")
fi

resolve_path() {
  if command -v python3 &>/dev/null; then
    python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "$1"
  elif command -v realpath &>/dev/null; then
    realpath "$1"
  elif command -v readlink &>/dev/null && readlink -f / &>/dev/null; then
    readlink -f "$1"
  else
    # Fallback: works for directories
    (cd "$1" 2>/dev/null && pwd) || echo "$1"
  fi
}

main_host="$(resolve_path "${paths[0]}")"

# Capture host HOME for path parity
HOST_HOME="$HOME"
HOST_CLAUDE_DIR="${HOST_HOME}/.claude"

# Ensure ~/.claude exists on host
mkdir -p "${HOST_CLAUDE_DIR}"

# Build container args separately from claude args
CLAUDE_MEMORY="${CLAUDE_MEMORY:-8g}"
container_argv=(
  container run --rm -it
  --memory "${CLAUDE_MEMORY}"
  --name "claude-contained-$$"
  --ssh
  -e "HOST_HOME=${HOST_HOME}"
  -e "HOST_UID=$(id -u)"
  -e "HOST_GID=$(id -g)"
  -w "${main_host}"
  --mount "type=bind,src=${HOST_CLAUDE_DIR},dst=${HOST_HOME}/.claude"
  --mount "type=bind,src=${HOST_HOME}/.claude.json,dst=${HOST_HOME}/.claude.json"
  --mount "type=bind,src=${main_host},dst=${main_host}"
)

claude_argv=(claude)

# Additional mounts at original host paths
for p in "${paths[@]:1}"; do
  hp="$(resolve_path "$p")"
  container_argv+=( --mount "type=bind,src=${hp},dst=${hp}" )
  claude_argv+=( --add-dir "${hp}" )
done

# Append user's claude args
if [[ ${#claude_args[@]} -gt 0 ]]; then
  claude_argv+=( "${claude_args[@]}" )
fi

if [[ $shell_mode -eq 1 ]]; then
  exec "${container_argv[@]}" claude-contained:latest bash
else
  exec "${container_argv[@]}" claude-contained:latest "${claude_argv[@]}"
fi
